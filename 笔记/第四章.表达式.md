# 第四章 表达式



## 左值(lvalue)和右值(rvalue)

- 当一个对象被用作右值，用的是对象的值（对它的内容进行操作）
- 当一个对象被用作左值，用的是对象的身份（对它所占的内存进行操作，可能覆盖，也可能是其他）



> 在需要右值的地方，可以用左值代替。但右值不能用作左值。

- Emmmm, 左值大概就是可以接受其他对象给他赋值。 而右值只能给别人赋值。
  - 同时是左值和右值的 是左值
  - 只是右值的 那就是右值.....OTZ
- **只能对左值使用后置的++  (``i++``) **

## 类型转换

### 隐式转换

- 自动执行的类型转换，并不需要程序员介入。

  - > 如果两种类型可以互相转换，那他们就是关联的。

- 发生隐式类型转换的条件

  - 大多数表达式中，比int类型小的整数值提升为较大的整数类型。
  - 非布尔值转换为布尔值
  - 初始化过程中，初始值转换为变量的类型。 **赋值语句**中，右侧运算对象转换为左侧运算对象的类型。
  - 如果算术运算或关系运算的对象存在多种类型，先转换成同种类型再计算。
  - 函数调用也会发生类型转换。

#### 算数转换

>  运算符的运算对象转换成最宽的类型，确保运算过程没有精度损失。

- 整型提升

  - 比int类型小的 bool \ char \ signed char \ unsigned char \ short \ unsigned short 提升成int类型 ， 或者unsigned int 类型。

  - 较大的char类型 wchar_t \ char16_t \ char32_t 提升成 int \ unsigned int \ long \ unsigned long \long long \unsigned long long 中最小的一个。

  - > 整型提升的前提是 转换后的类型要能容纳原类型所有可能的值。

  - > 32位编译器 (1byte= 8bit )
    >
    > char ：1个字节
    > char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
    > short int : 2个字节
    >
    > int： 4个字节
    > unsigned int : 4个字节
    > float: 4个字节
    > double: 8个字节
    > long: 4个字节
    > long long: 8个字节
    > unsigned long: 4个字节

  - > 64位编译器 (1byte = 16 bit)
    >
    > char ：1个字节
    >
    > - char*(即指针变量): 8个字节
    >
    > short int : 2个字节
    > int： 4个字节
    > unsigned int : 4个字节
    > float: 4个字节
    > double: 8个字节
    >
    > - long: 8个字节
    >
    > long long: 8个字节
    >
    > - unsigned long: 8个字节 

- 对于无符号类型的运算对象

  - 先执行整型提升。	
    -  如果结果 **类型匹配**，无需进行进一步的转换；
    -  如果提升后的类型 **都是带符号的**，或者都是**不**带符号的，则较小的转换成较大的。
    -  如果**一个带符号，一个无符号**。且**无符号的较大**，则带符号的转换成无符号的。
      - 如果带符号的较大，转换结果依赖机器。



### 显式转换

> 显式转换： 强制类型转换（cast）
>
> ``cast_name <type> (expression);``

- static_cast  : 只要不包含底层const，都可以使用
- const_cast ：只能改变运算对象的底层const
  - 如果对象本身不是个常量，使用强制类型转换获得写权限是合法的。
  - 但如果对象本身就是常量，则会产生未定义的后果。
- reinterpret_cast ： 为运算对象的位模式提供较低层次上的重新解释。 
  - 很危险。