# 类

1. 类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。 数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程技术。
   - 接口：用户所能执行的操作
   - 实现：类的数据成员，负责接口实现的函数体，以及定义类所需的各种私有函数。
2. 成员函数必须声明在类的内部，它的定义既可以在类的内部，也可以在类的外部。 而作为接口组成的非成员函数，定义和声明都在类的外部。定义在类内部的函数都是隐式inline函数。
3. 在成员函数内部，任何对类成员的访问都被看做this的隐式引用。this默认是一个指向类类型**非常量版本**的常量指针（顶层const），所以不能对常量对象（需要底层const）调用普通成员函数。
4. 常量成员函数（加const的目的是为了修改隐式this指针的类型，使常量对象可以调用这个成员函数。）： 在成员函数参数列表后加一个const ，表示this是一个底层const。此时常量对象可以使用该成员函数，但不能写入新值。const成员函数返回类型是常量引用。
5. 在类的外部定义成员函数时，**外部定义的成员名字必须包含它所属的类名**
6. 如果非成员函数是类的接口的组成部分，则声明应与类写在同一个头文件中。
7. 构造函数没有返回类型，可以重载，不能声明成const的。如果没有定义构造函数，则使用合成的默认构造函数： 优先使用成员**类内初始值**，若没有，则**默认初始化** 成员。C++11中，如果需要默认的行为，可以在参数列表后加**=default**,可以在类的内部，也可以在类的外部。
8. 构造函数初始值列表：在参数列表和花括号之间。如果某个数据成员没有出现在初始值列表，则以默认构造函数的方式隐式初始化。
9. 当类使用动态内存时，编译器合成的拷贝赋值销毁操作通常失效，应当使用string或vector来避免内存处理的复杂性。
10. 唯一的区别. struct默认public 而class 默认private；
11. 友元：允许其他类或函数访问它的非公有成员。一般最好在类定义开始或结束前的位置集中声明友元。友元的声明与类本身放置在同一个头文件中（类外）。
12. 用来定义类型的成员必须先定义，后使用 （typedef 或者 using） 。
13. 变量类型前加一个mutable。该成员变为可变成员，永远不会变成const。 即使在const对象的成员函数内，也可以修改这个成员。
14. 类也可以先声明后定义。叫做**前向声明** 。 声明后是一个**不完全类型**， 此时可以定义指向该类型的指针或引用，也可以声明以这种类型作为参数或返回类型的函数。 但不能创建类的对象。 所以一个类的成员函数不能是自己，但可以是**指向自身的指针或引用** 。
15. 友元可以是一个类，也可以是一个类中的某个函数， 如果友元函数有重载，并且要使用它的重载，则要分别声明。友元应该在类的外部进行声明，并且声明后才可以使用。
16. 类的定义：先编译成员的声明， 直到类全部可见后才编译函数体。
17. 名字查找 .......
18. 如果成员有const或引用或无默认构造函数的类，构造函数必须将其初始化。 类成员的初始化顺序与它们在类中的定义顺序一致，与构造函数初始值列表无关。（最好令构造函数初始值列表的顺序与类中成员的声明顺序一致）。
19. 委托构造函数：调用另一个构造函数。委托构造函数完毕后，再执行构造函数体的内容。
20. 默认构造函数： 当对象被默认初始化或者值初始化时自动执行默认构造函数。
    1. 默认初始化： 无初始值定义非静态变量； 类本身含有另一个类；类中的成员在构造列表没有显示初始化。
    2. 值初始化： 提供的初始值少于数组大小； 无初始值定义局部静态变量；显式值初始化。
    3. 不那么明显的一种情况：类的某些数据成员缺少默认构造函数。
21. 使用默认构造函数时，不加 “（）” 
22. 如果构造函数**只接受一个实参** ，实际上定义了转换为此类类型的隐式转换机制（多个实参的，不能隐式转换）。 编译器只会自动执行**一步**类型转换。  （字面值-> string -> 类 ， 这是两步）。 可以在构造函数前加一个``explicit`` 阻止隐式转换。只能在类内声明时使用explicit。  可是显式的强制类型转换，然后使用explicit的构造函数。
23. 聚合类：都是public； 没有构造函数；没有类内初始值；没有基类、virtual函数； 可以提供花括号的初始值列表，初始值的顺序必须与声明顺序一致。
24. 字面值常量类：所有数据成员都是字面类的聚合类； 或者不是聚合类，但数据成员都是字面值类型；至少要有一个constexpr构造函数（函数体是空的，必须初始化所有数据成员）； 类内初始值是常量表达式或初始值必须使用成员自己的constexpr表达式；类必须使用析构函数的默认定义。
25. 静态成员：与类本身相关，而不是与类的各个对象保持关联。类的对象中不包含任何与静态数据成员有关的数据。
26. 静态成员函数： 不与任何对象绑定，不包含this指针，不能声明成const，不能在static函数体内使用this指针。
27. 静态成员的访问：可以直接使用作用域运算符访问； 可以使用类的对象、引用、指针访问静态成员；成员函数不需要作用域运算符也可以访问；
28. **类的构造函数不会初始化静态成员。所以必须在类的外部定义和初始化每个静态成员**
29. 当静态成员定义在类外部时，必须指明成员所属的类名，不需要声明static。 一般不在类的内部初始化静态成员。
30. 静态成员的使用场景： 静态成员可以是不完全类型，而非静态成员只能使用本类的指针或引用； 静态成员可以做默认实参。


